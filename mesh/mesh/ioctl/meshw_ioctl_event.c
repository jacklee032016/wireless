/*
* $Id: meshw_ioctl_event.c,v 1.1.1.1 2006/11/30 17:00:40 lizhijie Exp $
*/

#include "_meshw_ioctl.h"

/* Size (in bytes) of various events */
static const int event_type_size[] =
{
	MESHW_EV_LCP_LEN,			/* MESHW_HEADER_TYPE_NULL */
	0,
	MESHW_EV_CHAR_LEN,			/* MESHW_HEADER_TYPE_CHAR */
	0,
	MESHW_EV_UINT_LEN,			/* MESHW_HEADER_TYPE_UINT */
	MESHW_EV_FREQ_LEN,			/* MESHW_HEADER_TYPE_FREQ */
	MESHW_EV_ADDR_LEN,			/* MESHW_HEADER_TYPE_ADDR */
	0,
	MESHW_EV_POINT_LEN,		/* Without variable payload */
	MESHW_EV_PARAM_LEN,		/* MESHW_HEADER_TYPE_PARAM */
	MESHW_EV_QUAL_LEN,			/* MESHW_HEADER_TYPE_QUAL */
};


/* Meta-data about all the additional standard Wireless Extension events we know about. */
static const struct meshw_ioctl_description	standard_event[] =
{
	/* MESHW_EV_TX_DROP */
	{ MESHW_HEADER_TYPE_ADDR, 0, 0, 0, 0, 0},
	/* MESHW_EV_QUAL */
	{ MESHW_HEADER_TYPE_QUAL, 0, 0, 0, 0, 0},
	/* MESHW_EV_CUSTOM */
	{ MESHW_HEADER_TYPE_POINT, 0, 1, 0, MESHW_CUSTOM_MAX, 0},
	/* MESHW_EV_NODE_REGISTERED */
	{ MESHW_HEADER_TYPE_ADDR, 0, 0, 0, 0, 0},
	/* MESHW_EV_NODE_EXPIRED */
	{ MESHW_HEADER_TYPE_ADDR, 0, 0, 0, 0, 0},
};
static const int standard_event_num = (sizeof(standard_event) /sizeof(struct meshw_ioctl_description));


/************************* EVENT PROCESSING *************************/
/* Process events generated by the wireless layer or the driver. */

/*
 * Main event dispatcher. Called from other parts and drivers.
 * Send the event on the apropriate channels.
 * May be called from interrupt context.
 */
void wireless_send_event(MESH_DEVICE *dev, unsigned int cmd, union meshw_req_data *wrqu, char *extra)
{
	const struct meshw_ioctl_description *	descr = NULL;
	int extra_len = 0;
	struct meshw_event  *event;		/* Mallocated whole event */
	int event_len;				/* Its size */
	int hdr_len;				/* Size of the event header */
	/* Don't "optimise" the following variable, it will crash */
	unsigned	cmd_index;		/* *MUST* be unsigned */

	/* Get the description of the IOCTL */
	if(cmd <= MESHW_IO_LAST)
	{
		cmd_index = cmd - MESHW_IO_FIRST;
		if(cmd_index < standard_ioctl_num)
			descr = &(standard_ioctl[cmd_index]);
	}
	else
	{
		cmd_index = cmd - MESHW_EV_FIRST;
		if(cmd_index < standard_event_num)
			descr = &(standard_event[cmd_index]);
	}

	/* Don't accept unknown events */
	if(descr == NULL)
	{
		/* Note : we don't return an error to the driver, because
		 * the driver would not know what to do about it. It can't
		 * return an error to the user, because the event is not
		 * initiated by a user request.
		 * The best the driver could do is to log an error message.
		 * We will do it ourselves instead...
		 */
	  	MESH_ERR_INFO( "%s (WE) : Invalid/Unknown Wireless Event (0x%04X)\n", dev->name, cmd);
		return;
	}
#ifdef WE_EVENT_DEBUG
	MESH_DEBUG_INFO("%s (WE) : Got event 0x%04X\n", dev->name, cmd);
	MESH_DEBUG_INFO("%s (WE) : Header type : %d, Token type : %d, size : %d, token : %d\n", dev->name, descr->header_type, descr->token_type, descr->token_size, descr->max_tokens);
#endif	/* WE_EVENT_DEBUG */

	/* Check extra parameters and set extra_len */
	if(descr->header_type == MESHW_HEADER_TYPE_POINT)
	{
		/* Check if number of token fits within bounds */
		if(wrqu->data.length > descr->max_tokens)
		{
		  	MESH_ERR_INFO( "%s (WE) : Wireless Event too big (%d)\n", dev->name, wrqu->data.length);
			return;
		}
		if(wrqu->data.length < descr->min_tokens)
		{
			MESH_ERR_INFO( "%s (WE) : Wireless Event too small (%d)\n", dev->name, wrqu->data.length);
			return;
		}
		/* Calculate extra_len - extra is NULL for restricted events */
		if(extra != NULL)
			extra_len = wrqu->data.length * descr->token_size;
#ifdef WE_EVENT_DEBUG
		MESH_DEBUG_INFO(MESH_DEBUG_IOCTL, "%s (WE) : Event 0x%04X, tokens %d, extra_len %d\n", dev->name, cmd, wrqu->data.length, extra_len);
#endif	/* WE_EVENT_DEBUG */
	}

	/* Total length of the event */
	hdr_len = event_type_size[descr->header_type];
	event_len = hdr_len + extra_len;

#ifdef WE_EVENT_DEBUG
	MESH_DEBUG_INFO(MESH_DEBUG_IOCTL, "%s (WE) : Event 0x%04X, hdr_len %d, event_len %d\n", dev->name, cmd, hdr_len, event_len);
#endif	/* WE_EVENT_DEBUG */

	/* Create temporary buffer to hold the event */
	event = kmalloc(event_len, GFP_ATOMIC);
	if(event == NULL)
		return;

	/* Fill event */
	event->len = event_len;
	event->cmd = cmd;
	memcpy(&event->u, wrqu, hdr_len - MESHW_EV_LCP_LEN);
	if(extra != NULL)
		memcpy(((char *) event) + hdr_len, extra, extra_len);

#ifdef WE_EVENT_NETLINK
	/* rtnetlink event channel */
	rtmsg_iwinfo(dev, (char *) event, event_len);
#endif	/* WE_EVENT_NETLINK */

	/* Cleanup */
	kfree(event);

	return;		/* Always success, I guess ;-) */
}

